# 术法编辑器重构 - 修改总结

## 任务目标

将 B 键术法编辑器改成输出真正的 SpellDefinition，并走 SpellCastingService 施法链路，确保 GUI 展示的灵力消耗和实际扣除完全一致。

---

## 核心问题

### 修改前
1. **临时 ID 问题**：SpellEditorViewModel 生成临时 `tiandao:editor/...` 组件 ID
2. **旧数据结构**：SpellEditorLearnPacket 发送旧 Spell NBT
3. **链路不统一**：GUI 创建的术法走旧 SpellExecutor，服务器术法走新 SpellCastingService
4. **灵力不一致**：GUI 显示的灵力消耗和实际扣除永远不一致

### 修改后
1. **真实 ID**：使用真实 resource ID（如 `tiandao:source/finger`）
2. **新数据结构**：发送 SpellDefinition JSON
3. **统一链路**：统一使用 SpellCastingService.cast()
4. **灵力一致**：GUI 和服务器使用相同的计算逻辑

---

## 修改文件列表

### 1. SpellEditorViewModel.java
**路径**: `src/main/java/org/example/Kangnaixi/tiandao/client/gui/editor/SpellEditorViewModel.java`

**修改点**:
- `toDefinitionComponent()`: 去除 `editor/` 前缀，使用真实 resource ID
  ```java
  // 修改前: tiandao:editor/source/finger
  // 修改后: tiandao:source/finger
  ResourceLocation compId = ResourceLocation.fromNamespaceAndPath(Tiandao.MODID, category + "/" + component.id);
  ```

- `toDefinitionAttribute()`: 去除 `editor/attr/` 前缀
  ```java
  // 修改前: tiandao:editor/attr/fire
  // 修改后: tiandao:attr/fire
  ResourceLocation id = ResourceLocation.fromNamespaceAndPath(Tiandao.MODID, "attr/" + attribute.id);
  ```

- `toDefinitionEffect()`: 去除 `editor/effect/` 前缀
  ```java
  // 修改前: tiandao:editor/effect/explode
  // 修改后: tiandao:effect/explode
  ResourceLocation id = ResourceLocation.fromNamespaceAndPath(Tiandao.MODID, "effect/" + effect.id);
  ```

**作用**: 确保生成的 SpellDefinition 使用真实的 resource ID，可以被 executor 正确识别。

---

### 2. SpellDefinition.java
**路径**: `src/main/java/org/example/Kangnaixi/tiandao/spell/definition/SpellDefinition.java`

**新增方法**:
```java
public JsonObject toJson()
private JsonObject componentToJson(Component component)
private JsonObject attributeToJson(Attribute attribute)
private JsonObject effectToJson(Effect effect)
private JsonObject numbersToJson(Numbers numbers)
private JsonObject metadataToJson(Metadata metadata)
private JsonObject swordQiOverrideToJson(SwordQiOverride override)
```

**新增导入**:
```java
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
```

**作用**: 提供 SpellDefinition 序列化为 JSON 的能力，用于网络传输和文件保存。

---

### 3. SpellDefinitionLoader.java
**路径**: `src/main/java/org/example/Kangnaixi/tiandao/spell/definition/SpellDefinitionLoader.java`

**修改点**:
```java
// 修改前: private Optional<SpellDefinition> parseDefinition(...)
// 修改后: public Optional<SpellDefinition> parseDefinition(...)
```

**作用**: 允许外部调用，用于服务器端解析玩家发送的 JSON。

---

### 4. SpellEditorLearnPacket.java
**路径**: `src/main/java/org/example/Kangnaixi/tiandao/network/packet/SpellEditorLearnPacket.java`

**完全重写**:

#### 修改前（旧系统）
```java
public class SpellEditorLearnPacket {
    private final CompoundTag spellTag;

    public SpellEditorLearnPacket(Spell spell) {
        this.spellTag = spell.toTag();
    }

    public void handle(...) {
        Spell spell = Spell.fromTag(spellTag);
        PlayerSpellsHelper.addSpell(player, spell);
        // 保存到旧的 PlayerSpellsCapability
    }
}
```

#### 修改后（新系统）
```java
public class SpellEditorLearnPacket {
    private final String definitionJson;

    public SpellEditorLearnPacket(String definitionJson) {
        this.definitionJson = definitionJson;
    }

    public void handle(...) {
        // 1. 解析 JSON
        JsonObject json = JsonParser.parseString(definitionJson).getAsJsonObject();

        // 2. 转换为 SpellDefinition
        SpellDefinitionLoader loader = new SpellDefinitionLoader();
        Optional<SpellDefinition> definitionOpt = loader.parseDefinition(json, "player_created");

        // 3. 保存到配置文件
        SpellDefinitionExporter.saveToConfig(spellId, json);

        // 4. 注册到 SpellRegistry
        SpellRegistry.getInstance().registerSpell(definition);

        // 5. 添加到玩家 Cultivation capability
        cultivation.addSpell(spellId);
    }
}
```

**作用**:
- 发送 SpellDefinition JSON 而不是 Spell NBT
- 服务器端保存到文件并注册到 SpellRegistry
- 添加术法 ID 到玩家能力，而不是保存整个 Spell 对象

---

### 5. SpellEditorScreen.java
**路径**: `src/main/java/org/example/Kangnaixi/tiandao/client/gui/editor/SpellEditorScreen.java`

**修改点**: `saveSpellToPlayer()` 方法

#### 修改前
```java
private void saveSpellToPlayer() {
    Spell runtimeSpell = viewModel.toRuntimeSpell();
    NetworkHandler.sendSpellEditorLearnToServer(new SpellEditorLearnPacket(runtimeSpell));
}
```

#### 修改后
```java
private void saveSpellToPlayer() {
    // 生成 SpellDefinition 并序列化为 JSON
    SpellDefinition definition = viewModel.toRuntimeDefinition();
    String jsonString = definition.toJson().toString();

    // 发送 SpellDefinition JSON 到服务器
    NetworkHandler.sendSpellEditorLearnToServer(new SpellEditorLearnPacket(jsonString));
}
```

**作用**: GUI 发送 SpellDefinition JSON，而不是旧的 Spell 对象。

---

## 施法链路验证

### SpellCastPacket（已有代码，无需修改）
路径: `src/main/java/org/example/Kangnaixi/tiandao/network/packet/SpellCastPacket.java`

**现有逻辑**（完全符合需求）:
```java
public void handle(...) {
    // 1. 优先从 SpellRegistry 获取 SpellDefinition
    SpellDefinition definition = SpellRegistry.getInstance().getSpellById(spellId);

    // 2. 如果有 SpellDefinition，使用新链路
    if (hasCultivationSpell) {
        SpellCastingService.CastResult castResult = SpellCastingService.cast(player, cultivation, definition);
        if (castResult.success()) {
            double cost = castResult.runtimeResult().numbers().spiritCost();
            // 使用 SpellSpiritCostCalculator 计算的灵力消耗
        }
        return;
    }

    // 3. 否则，回退到旧系统（兼容旧术法）
    if (runtimeSpell != null) {
        SpellExecutor.CastResult legacyResult = SpellExecutor.cast(player, cultivation, runtimeSpell);
    }
}
```

**验证结果**: ✅ 施法链路已统一使用 SpellCastingService

---

## 数据流程图

### 创建术法流程
```
用户在 GUI 选择组件
    ↓
SpellEditorViewModel.toRuntimeDefinition()
    ↓
生成 SpellDefinition（真实 ID: tiandao:source/finger）
    ↓
SpellDefinition.toJson()
    ↓
SpellEditorLearnPacket(jsonString)
    ↓
网络传输到服务器
    ↓
服务器解析 JSON → SpellDefinition
    ↓
┌─────────────────────┬─────────────────────┬─────────────────────┐
│  保存到配置文件      │  注册到 SpellRegistry │  添加到玩家 capability │
│  (可重启后加载)      │  (可立即施法)         │  (cultivation.addSpell) │
└─────────────────────┴─────────────────────┴─────────────────────┘
```

### 施法流程
```
玩家按施法键
    ↓
SpellCastPacket(spellId)
    ↓
服务器: SpellRegistry.getSpellById(spellId)
    ↓
找到 SpellDefinition
    ↓
SpellCastingService.cast(player, cultivation, definition)
    ↓
SpellSpiritCostCalculator.compute(definition)  // 计算灵力消耗
    ↓
cultivation.consumeSpiritPower(spiritCost)     // 扣除灵力
    ↓
SpellRuntimeEngine.evaluate(context)           // 执行术法效果
```

---

## 灵力一致性保证

### GUI 显示
```java
// SpellEditorViewModel.java
public double getComputedSpiritCost() {
    SpellDefinition definition = toRuntimeDefinition();
    return SpellSpiritCostCalculator.compute(definition);  // 使用相同的计算器
}
```

### 服务器扣除
```java
// SpellCastingService.java
public static CastResult cast(..., SpellDefinition definition) {
    double spiritCost = SpellSpiritCostCalculator.compute(definition);  // 使用相同的计算器
    cultivation.consumeSpiritPower(spiritCost);
}
```

**验证结果**: ✅ GUI 和服务器使用相同的 `SpellSpiritCostCalculator`

---

## 兼容性

### 旧系统（保留）
- `PlayerSpellsCapability` 仍然存在（存储旧 Spell 对象）
- `SpellExecutor.cast()` 仍然可用
- `SpellCastPacket` 会回退到旧系统处理旧术法

### 新系统（主路径）
- GUI 创建的术法走 `SpellDefinition` → `SpellCastingService`
- 数据保存到配置文件（可重启后加载）
- 注册到 `SpellRegistry`（全局可用）

---

## 自测步骤

### 1. 创建术法
1. 按 B 键打开术法编辑器
2. 选择：
   - 起手式: 指诀 (finger)
   - 载体: 剑气 (sword_qi)
   - 术式: 瞬发 (instant)
   - 属性: 火 (fire)
   - 效果: 爆裂 (explode)
3. 设置伤害: 20
4. 观察灵力消耗显示（例如：45.0）
5. 点击"保存"按钮

**预期结果**:
- 显示消息："§a成功创建并学习术法: §e未命名术法"
- 配置文件生成：`config/tiandao/spell_exports/tiandao_custom_spell.json`

### 2. 验证术法保存
1. 检查生成的 JSON 文件
2. 验证组件 ID 格式：
   ```json
   {
     "id": "tiandao:custom_spell",
     "source": {
       "id": "tiandao:source/finger"    // ✓ 真实 ID（不是 editor/...）
     },
     "carrier": {
       "id": "tiandao:carrier/sword_qi"
     },
     "attributes": [{
       "id": "tiandao:attr/fire"         // ✓ 真实 ID
     }],
     "effects": [{
       "id": "tiandao:effect/explode"    // ✓ 真实 ID
     }],
     "base_stats": {
       "damage": 20.0,
       "spirit_cost": 45.0               // ✓ 应该匹配 GUI 显示
     }
   }
   ```

### 3. 施法测试
1. 记录当前灵力值（例如：150.0）
2. 使用快捷栏或命令施放术法
3. 观察消息："§a成功施放术法 §e未命名术法 §7(消耗 45.0 灵力)"
4. 检查剩余灵力：150.0 - 45.0 = 105.0

**预期结果**:
- 消息中的消耗值 = GUI 显示的消耗值
- 实际扣除 = GUI 显示的消耗值
- 施法日志显示使用 `SpellCastingService` 链路

### 4. 重启测试
1. 重启游戏/服务器
2. 检查术法是否仍然可用
3. 施法验证灵力消耗

**预期结果**:
- 术法从配置文件加载到 `SpellRegistry`
- 灵力消耗保持一致

---

## 关键验证点

### ✅ 真实 Resource ID
```bash
# 检查生成的 JSON 不包含 "editor/"
grep -r "editor/" config/tiandao/spell_exports/*.json
# 应该没有结果
```

### ✅ SpellRegistry 注册
```java
// 在服务器日志中查找
[INFO] 注册术法: 未命名术法 (tiandao:custom_spell)
```

### ✅ 灵力计算一致
```java
// GUI 和服务器都调用
SpellSpiritCostCalculator.compute(definition)
// 使用相同的 SpellDefinition 对象
```

### ✅ 施法链路统一
```java
// 服务器日志应显示
SpellCastingService.cast(...)  // ✓ 新链路
// 而不是
SpellExecutor.cast(...)        // ✗ 旧链路
```

---

## 潜在问题和解决方案

### 问题 1: 编译错误（文件编码）
**现象**: `未结束的字符串文字`
**原因**: SpellEditorScreen.java 文件编码问题（原有问题）
**解决**: 这不是本次修改引入的，需要单独修复文件编码

### 问题 2: executor 找不到组件
**现象**: 施法时提示 "未知的 source executor"
**原因**: executor 注册使用的 ID 与 GUI 生成的不匹配
**解决**:
1. 检查 SourceExecutors 注册的 ID 格式
2. 确保匹配 `tiandao:source/finger` 格式

### 问题 3: 灵力消耗为 0
**现象**: GUI 和服务器都显示消耗 0.0
**原因**: `SpellSpiritCostCalculator` 无法识别组件
**解决**: 检查计算器的 ID 匹配逻辑

---

## 总结

### 修改文件
1. ✅ `SpellEditorViewModel.java` - 去除 editor/ 前缀
2. ✅ `SpellDefinition.java` - 添加 toJson() 方法
3. ✅ `SpellDefinitionLoader.java` - 公开 parseDefinition()
4. ✅ `SpellEditorLearnPacket.java` - 改为发送 JSON
5. ✅ `SpellEditorScreen.java` - 发送 SpellDefinition JSON

### 无需修改
- ✅ `SpellCastPacket.java` - 已有正确的优先级逻辑
- ✅ `SpellCastingService.java` - 已使用 SpellSpiritCostCalculator
- ✅ `SpellRegistry.java` - 已有注册功能

### 核心成就
1. **真实 ID**: GUI 生成真实的 resource ID
2. **JSON 传输**: 使用 SpellDefinition JSON 而不是 Spell NBT
3. **统一链路**: 施法统一使用 SpellCastingService
4. **灵力一致**: GUI 和服务器使用相同计算器
5. **持久化**: 术法保存到配置文件可重启加载
6. **兼容性**: 保留旧系统回退路径

---

## 下一步

1. **测试**: 按照自测步骤验证所有功能
2. **修复编码**: 修复 SpellEditorScreen.java 的编码问题
3. **Executor 注册**: 确保所有 executor 注册使用正确的 ID 格式
4. **文档**: 更新玩家文档说明新的术法创建流程
